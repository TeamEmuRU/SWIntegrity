import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.math.BigInteger;

/**
 * Contains the code for the c++ flavor of the Integer Overflow Vulnerability.
 * #24 CWE-190: http://cwe.mitre.org/top25/#CWE-190
 * 
 * @author Eric Stephens
 * 
 * <p>: Parses through the file looking for any place where an integer, double, char, uint_8, uint_16, etc...
 * is given a value. If that value is a number this class will check to see if that number is out of bounds or
 * if it is not a number it will check to see if the number/ variable/ arithmetic expression is first checked
 * for being out of bounds before being assigned to the variable </p>
 */
public class CppIntegerOverflowVulnerability implements Vulnerability {

	@Override
	public List<Integer> run(Analyzer ana) {
			List<Integer> intOverflowList = new ArrayList<>();
			Map<Integer, String> assignments;
			String nonNumericValue = null;
			
			CppAnalyzer cppana=(CppAnalyzer)ana;
			String fileContents = cppana.getFileContents();
			for (CppAnalyzer.Variable var: cppana.getVariables())
			{
				
				switch (var.getType()) {
				case "char":
					assignments = var.getAssignments();
					for(Map.Entry<Integer, String> assignment : assignments.entrySet()) {
						try { //Tests to see if the variable was given an assignment greater then the max or less then the min value
							  // if it was given a numeric value
							BigInteger value = new BigInteger(assignment.getValue());
							
							if (value.toString().compareTo("255") > 0 || value.toString().compareTo("-127") < 0)
								intOverflowList.add(assignment.getKey());
						}
						catch(NumberFormatException e)
						{
							nonNumericValue = assignment.getValue();
							//Check if the char has greater then one element. if it does you are looking at an expression. if not you are looking at a single character
							if (nonNumericValue.length() > 1) {
								String[] words = fileContents.split(var.name + " = " +assignment.getValue());
								if (!words[0].contains(nonNumericValue + " < = 255") && !words[0].contains(nonNumericValue + " > = - 127")) {
									intOverflowList.add(assignment.getKey());
								} 
								nonNumericValue = null;
							}
						}
						
					}
					break;
					
				case "unsigned char":
					assignments = var.getAssignments();
					for(Map.Entry<Integer, String> assignment : assignments.entrySet()) {
						try { 
							BigInteger value = new BigInteger(assignment.getValue());
							if (value.toString().compareTo("255") > 0 || value.toString().compareTo("0") < 0)
								intOverflowList.add(assignment.getKey());
						}
						catch(NumberFormatException e)
						{
							nonNumericValue = assignment.getValue();
		
							if (nonNumericValue.length() > 1) {
								String[] words = fileContents.split(var.name + " = " +assignment.getValue());
								if (!words[0].contains(nonNumericValue + " < = 255") && !words[0].contains(nonNumericValue + " > 0")) {
									intOverflowList.add(assignment.getKey());
								} 
								nonNumericValue = null;
							}
						}
						
					}
					break;
					
				case "signed char":
					assignments = var.getAssignments();
					for(Map.Entry<Integer, String> assignment : assignments.entrySet()) {
						try { 
							BigInteger value = new BigInteger(assignment.getValue());
							if (value.toString().compareTo("127") > 0 || value.toString().compareTo("-127") < 0)
								intOverflowList.add(assignment.getKey());
						}
						catch(NumberFormatException e)
						{
							nonNumericValue = assignment.getValue();
							
							if (nonNumericValue.length() > 1) {
								String[] words = fileContents.split(var.name + " = " +assignment.getValue());
								if (!words[0].contains(nonNumericValue + " < = 127") && !words[0].contains(nonNumericValue + " > = - 127")) {
									intOverflowList.add(assignment.getKey());
								} 
								nonNumericValue = null;
							}
						}
						
					}
					break;
				
				case "short":
					assignments = var.getAssignments();
					for(Map.Entry<Integer, String> assignment : assignments.entrySet()) {
						
						try {
							BigInteger value = new BigInteger(assignment.getValue());
							if (value.toString().compareTo("32767") > 0 || value.toString().compareTo("-32767") < 0)
								intOverflowList.add(assignment.getKey());
						}
						catch(NumberFormatException e)
						{
							nonNumericValue = assignment.getValue();
							String[] words = fileContents.split(var.name + " = " +assignment.getValue());
							//checks if the expression was ever checked against the max or min value for the respective data type
							//TODO Add more ways to handle this
							if (!words[0].contains(nonNumericValue + " < = 32767") && !words[0].contains(nonNumericValue + " > = - 32767")) {
								intOverflowList.add(assignment.getKey());
							} 
							nonNumericValue = null;
						}
						
					}
					break;
					
				case "unsigned short":
					assignments = var.getAssignments();
					for(Map.Entry<Integer, String> assignment : assignments.entrySet()) {
						try { 
							BigInteger value = new BigInteger(assignment.getValue());
							if (value.toString().compareTo("65535") > 0 || value.toString().compareTo("0") < 0)
								intOverflowList.add(assignment.getKey());
						}
						catch(NumberFormatException e)
						{
							nonNumericValue = assignment.getValue();
							String[] words = fileContents.split(var.name + " = " +assignment.getValue());
							if (!words[0].contains(nonNumericValue + " < = 65535") && !words[0].contains(nonNumericValue + " > = 0")) {
								intOverflowList.add(assignment.getKey());
							}
							nonNumericValue = null;
						}
					}
					
					break;
					
			
				case "long":
				case "int":
					assignments = var.getAssignments();
					for(Map.Entry<Integer, String> assignment : assignments.entrySet()) {
						try {
							BigInteger value = new BigInteger(assignment.getValue());
							if (value.toString().compareTo("2147483647") > 0 || value.toString().compareTo("-2147483648") < 0)
								intOverflowList.add(assignment.getKey());
						}
						catch(NumberFormatException e)
						{
							nonNumericValue = assignment.getValue();
							String[] words = fileContents.split(var.name + " = " +assignment.getValue());
							
							if (!words[0].contains(nonNumericValue + " < = 2147483647") && !words[0].contains(nonNumericValue + " > = - 2147483647")) {
								intOverflowList.add(assignment.getKey());
							}
							nonNumericValue = null;
							
						}
						
					}
					break;
					
				case "unsigned int":
					assignments = var.getAssignments();
					for(Map.Entry<Integer, String> assignment : assignments.entrySet()) {
						try {
							BigInteger value = new BigInteger(assignment.getValue());
							if (value.toString().compareTo("4294967295") > 0 || value.toString().compareTo("0") < 0)
								intOverflowList.add(assignment.getKey());
						}
						catch(NumberFormatException e)
						{
							nonNumericValue = assignment.getValue();
							String[] words = fileContents.split(var.name + " = " +assignment.getValue());
							if (!words[0].contains(nonNumericValue + " > = 4294967295") && !words[0].contains(nonNumericValue + " < = 0")) {
								intOverflowList.add(assignment.getKey());
							}
							nonNumericValue = null;
						}
						
					}
					break;
					
					
				}
			}
			
return intOverflowList;
}
}