import java.util.ArrayList;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.regex.Matcher;
import java.util.regex.Pattern;


/**
 * This vulnerability searches for access types that point to a place in memory that no longer
 * contains what the programmer thinks it contains.
 * @author Joe Antaki
 */
public class AdaDanglingPointerVulnerability implements Vulnerability {

	@Override
	public List<Integer> run(Analyzer ana) {
		AdaAnalyzer aana=(AdaAnalyzer)ana;
		LinkedList<Integer> lines = new LinkedList<>();
		//case 1: access type variables that have not been freed still point to another access type variable that was freed
				Pattern deallocatorMethod = Pattern.compile("procedure \\S{1,} is new Ada.Unchecked_Deallocation");
				ArrayList<String> methodList = new ArrayList<>();
				HashSet<String> dangerousVariables = new HashSet<>();
				HashSet<AdaAnalyzer.Variable> danglers = new HashSet<>();
				Matcher matcher = deallocatorMethod.matcher(aana.rawCode);
				while(matcher.find()){
					methodList.add(aana.getFileContents().substring(matcher.start()+10, aana.rawCode.indexOf("is new", matcher.start())-1));
				}
				for(String m : methodList) {
					Pattern methodCall = Pattern.compile(m + "(\\S{1,})");
					Matcher mat = methodCall.matcher(aana.rawCode);
					while(mat.find()){
						String found = mat.group();
						dangerousVariables.add(found.substring(m.length() + 1, found.lastIndexOf(")")));
					}
				}
				for(String v : dangerousVariables){
					for(AdaAnalyzer.Variable va : aana.variables.values()){
						Pattern assign = Pattern.compile(va.getName() + "\\s*:\\s*=\\s*" + v);
						Matcher mm = assign.matcher(aana.rawCode);
						if(mm.find() && !dangerousVariables.contains(va.getName())){ //if var := myFunction is called, and myFunction returns an access type, this won't catch it
							danglers.add(va);
						}
					}
				}
				//case 2: access type variable is assigned to a local variable that has become out of scope, and the access type variable is not reassigned to something else
				int accessScope = 0;
				int localVariableScope = 0;
				String scope="";
				String str="";
				Pattern alphaUnderscore = Pattern.compile("[a-zA-Z_]+");
				for(AdaAnalyzer.Variable v : aana.variables.values()) {
					if (aana.accessTypes.contains(v.getType())) { //the variable is an access type
						scope = String.valueOf(v.getScope().charAt(v.getScope().length() - 2));
						accessScope = Integer.parseInt(scope); //get the scope that this variable was declared in

						for (Integer key : v.getAssignments().keySet()) { //look through all the assignments of this variable
							Matcher mm = alphaUnderscore.matcher(v.getAssignments().get(key));
							if (mm.find()) {
								str = mm.group();
							}
							for (AdaAnalyzer.Variable q : aana.variables.values()) {
								if (q.getName().equals(str)) {//the assignment is another variable and not a literal, procedure or function
									AdaAnalyzer.Variable myLocalVariable = q;
									scope = String.valueOf(myLocalVariable.getScope().charAt(myLocalVariable.getScope().length() - 2));
									localVariableScope = Integer.parseInt(scope); //get this new variable's scope

									if (localVariableScope > accessScope) { //there is danger of the local variable going out of scope while the access variable is still pointing to it
										lines.add(key);
									}
								}
							}
						}
					}
				}
					Iterator<AdaAnalyzer.Variable> it = danglers.iterator();
					while (it.hasNext()) {
						for (Map.Entry<Integer, String> e : it.next().getAssignments().entrySet()) {
							if (dangerousVariables.contains(e.getValue().trim())) {
								lines.add(e.getKey());
							}
						}
					}
			return lines;
	}
}
